diff --git a/dist/vue-wc-wrapper.js b/dist/vue-wc-wrapper.js
index 721bf1f13b0deca95e11d8b6803ccedda0a77cfc..cb09cc500169991638d6ed6186e537f21da19e77 100644
--- a/dist/vue-wc-wrapper.js
+++ b/dist/vue-wc-wrapper.js
@@ -1,36 +1,36 @@
-const camelizeRE = /-(\w)/g;
-const camelize = str => {
-  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : '')
-};
+const camelizeRE = /-(\w)/g
+const camelize = (str) => {
+  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))
+}
 
-const hyphenateRE = /\B([A-Z])/g;
-const hyphenate = str => {
+const hyphenateRE = /\B([A-Z])/g
+const hyphenate = (str) => {
   return str.replace(hyphenateRE, '-$1').toLowerCase()
-};
+}
 
-function getInitialProps (propsList) {
-  const res = {};
-  propsList.forEach(key => {
-    res[key] = undefined;
-  });
+function getInitialProps(propsList) {
+  const res = {}
+  propsList.forEach((key) => {
+    res[key] = undefined
+  })
   return res
 }
 
-function injectHook (options, key, hook) {
-  options[key] = [].concat(options[key] || []);
-  options[key].unshift(hook);
+function injectHook(options, key, hook) {
+  options[key] = [].concat(options[key] || [])
+  options[key].unshift(hook)
 }
 
-function callHooks (vm, hook) {
+function callHooks(vm, hook) {
   if (vm) {
-    const hooks = vm.$options[hook] || [];
-    hooks.forEach(hook => {
-      hook.call(vm);
-    });
+    const hooks = vm.$options[hook] || []
+    hooks.forEach((hook) => {
+      hook.call(vm)
+    })
   }
 }
 
-function createCustomEvent (name, args) {
+function createCustomEvent(name, args) {
   return new CustomEvent(name, {
     bubbles: false,
     cancelable: false,
@@ -38,10 +38,10 @@ function createCustomEvent (name, args) {
   })
 }
 
-const isBoolean = val => /function Boolean/.test(String(val));
-const isNumber = val => /function Number/.test(String(val));
+const isBoolean = (val) => /function Boolean/.test(String(val))
+const isNumber = (val) => /function Number/.test(String(val))
 
-function convertAttributeValue (value, name, { type } = {}) {
+function convertAttributeValue(value, name, { type } = {}) {
   if (isBoolean(type)) {
     if (value === 'true' || value === 'false') {
       return value === 'true'
@@ -51,22 +51,22 @@ function convertAttributeValue (value, name, { type } = {}) {
     }
     return value
   } else if (isNumber(type)) {
-    const parsed = parseFloat(value, 10);
+    const parsed = parseFloat(value, 10)
     return isNaN(parsed) ? value : parsed
   } else {
     return value
   }
 }
 
-function toVNodes (h, children) {
-  const res = [];
+function toVNodes(h, children) {
+  const res = []
   for (let i = 0, l = children.length; i < l; i++) {
-    res.push(toVNode(h, children[i]));
+    res.push(toVNode(h, children[i]))
   }
   return res
 }
 
-function toVNode (h, node) {
+function toVNode(h, node) {
   if (node.nodeType === 3) {
     return node.data.trim() ? node.data : null
   } else if (node.nodeType === 1) {
@@ -75,10 +75,10 @@ function toVNode (h, node) {
       domProps: {
         innerHTML: node.innerHTML
       }
-    };
+    }
     if (data.attrs.slot) {
-      data.slot = data.attrs.slot;
-      delete data.attrs.slot;
+      data.slot = data.attrs.slot
+      delete data.attrs.slot
     }
     return h(node.tagName, data)
   } else {
@@ -86,182 +86,188 @@ function toVNode (h, node) {
   }
 }
 
-function getAttributes (node) {
-  const res = {};
+function getAttributes(node) {
+  const res = {}
   for (let i = 0, l = node.attributes.length; i < l; i++) {
-    const attr = node.attributes[i];
-    res[attr.nodeName] = attr.nodeValue;
+    const attr = node.attributes[i]
+    res[attr.nodeName] = attr.nodeValue
   }
   return res
 }
 
-function wrap (Vue, Component) {
-  const isAsync = typeof Component === 'function' && !Component.cid;
-  let isInitialized = false;
-  let hyphenatedPropsList;
-  let camelizedPropsList;
-  let camelizedPropsMap;
+function wrap(Vue, Component) {
+  const isAsync = typeof Component === 'function' && !Component.cid
+  let isInitialized = false
+  let hyphenatedPropsList
+  let camelizedPropsList
+  let camelizedPropsMap
 
-  function initialize (Component) {
+  function initialize(Component) {
     if (isInitialized) return
 
-    const options = typeof Component === 'function'
-      ? Component.options
-      : Component;
+    const options =
+      typeof Component === 'function' ? Component.options : Component
 
     // extract props info
     const propsList = Array.isArray(options.props)
       ? options.props
-      : Object.keys(options.props || {});
-    hyphenatedPropsList = propsList.map(hyphenate);
-    camelizedPropsList = propsList.map(camelize);
-    const originalPropsAsObject = Array.isArray(options.props) ? {} : options.props || {};
+      : Object.keys(options.props || {})
+    hyphenatedPropsList = propsList.map(hyphenate)
+    camelizedPropsList = propsList.map(camelize)
+    const originalPropsAsObject = Array.isArray(options.props)
+      ? {}
+      : options.props || {}
     camelizedPropsMap = camelizedPropsList.reduce((map, key, i) => {
-      map[key] = originalPropsAsObject[propsList[i]];
+      map[key] = originalPropsAsObject[propsList[i]]
       return map
-    }, {});
+    }, {})
 
     // proxy $emit to native DOM events
     injectHook(options, 'beforeCreate', function () {
-      const emit = this.$emit;
+      const emit = this.$emit
       this.$emit = (name, ...args) => {
-        this.$root.$options.customElement.dispatchEvent(createCustomEvent(name, args));
+        this.$root.$options.customElement.dispatchEvent(
+          createCustomEvent(name, args)
+        )
         return emit.call(this, name, ...args)
-      };
-    });
+      }
+    })
 
     injectHook(options, 'created', function () {
       // sync default props values to wrapper on created
-      camelizedPropsList.forEach(key => {
-        this.$root.props[key] = this[key];
-      });
-    });
+      camelizedPropsList.forEach((key) => {
+        this.$root.props[key] = this[key]
+      })
+    })
 
     // proxy props as Element properties
-    camelizedPropsList.forEach(key => {
+    camelizedPropsList.forEach((key) => {
       Object.defineProperty(CustomElement.prototype, key, {
-        get () {
+        get() {
           return this._wrapper.props[key]
         },
-        set (newVal) {
-          this._wrapper.props[key] = newVal;
+        set(newVal) {
+          this._wrapper.props[key] = newVal
         },
         enumerable: false,
         configurable: true
-      });
-    });
+      })
+    })
 
-    isInitialized = true;
+    isInitialized = true
   }
 
-  function syncAttribute (el, key) {
-    const camelized = camelize(key);
-    const value = el.hasAttribute(key) ? el.getAttribute(key) : undefined;
+  function syncAttribute(el, key) {
+    const camelized = camelize(key)
+    const value = el.hasAttribute(key) ? el.getAttribute(key) : undefined
     el._wrapper.props[camelized] = convertAttributeValue(
       value,
       key,
       camelizedPropsMap[camelized]
-    );
+    )
   }
 
   class CustomElement extends HTMLElement {
-    constructor () {
-      const self = super();
-      self.attachShadow({ mode: 'open' });
+    constructor() {
+      const self = super()
 
-      const wrapper = self._wrapper = new Vue({
+      const wrapper = (self._wrapper = new Vue({
         name: 'shadow-root',
         customElement: self,
-        shadowRoot: self.shadowRoot,
-        data () {
+        data() {
           return {
             props: {},
             slotChildren: []
           }
         },
-        render (h) {
-          return h(Component, {
-            ref: 'inner',
-            props: this.props
-          }, this.slotChildren)
+        render(h) {
+          return h(
+            Component,
+            {
+              ref: 'inner',
+              props: this.props
+            },
+            this.slotChildren
+          )
         }
-      });
+      }))
 
       // Use MutationObserver to react to future attribute & slot content change
-      const observer = new MutationObserver(mutations => {
-        let hasChildrenChange = false;
+      const observer = new MutationObserver((mutations) => {
+        let hasChildrenChange = false
         for (let i = 0; i < mutations.length; i++) {
-          const m = mutations[i];
+          const m = mutations[i]
           if (isInitialized && m.type === 'attributes' && m.target === self) {
-            syncAttribute(self, m.attributeName);
+            syncAttribute(self, m.attributeName)
           } else {
-            hasChildrenChange = true;
+            hasChildrenChange = true
           }
         }
         if (hasChildrenChange) {
-          wrapper.slotChildren = Object.freeze(toVNodes(
-            wrapper.$createElement,
-            self.childNodes
-          ));
+          wrapper.slotChildren = Object.freeze(
+            toVNodes(wrapper.$createElement, self.childNodes)
+          )
         }
-      });
+      })
       observer.observe(self, {
         childList: true,
         subtree: true,
         characterData: true,
         attributes: true
-      });
+      })
     }
 
-    get vueComponent () {
+    get vueComponent() {
       return this._wrapper.$refs.inner
     }
 
-    connectedCallback () {
-      const wrapper = this._wrapper;
+    connectedCallback() {
+      const wrapper = this._wrapper
       if (!wrapper._isMounted) {
         // initialize attributes
         const syncInitialAttributes = () => {
-          wrapper.props = getInitialProps(camelizedPropsList);
-          hyphenatedPropsList.forEach(key => {
-            syncAttribute(this, key);
-          });
-        };
+          wrapper.props = getInitialProps(camelizedPropsList)
+          hyphenatedPropsList.forEach((key) => {
+            syncAttribute(this, key)
+          })
+        }
 
         if (isInitialized) {
-          syncInitialAttributes();
+          syncInitialAttributes()
         } else {
           // async & unresolved
-          Component().then(resolved => {
-            if (resolved.__esModule || resolved[Symbol.toStringTag] === 'Module') {
-              resolved = resolved.default;
+          Component().then((resolved) => {
+            if (
+              resolved.__esModule ||
+              resolved[Symbol.toStringTag] === 'Module'
+            ) {
+              resolved = resolved.default
             }
-            initialize(resolved);
-            syncInitialAttributes();
-          });
+            initialize(resolved)
+            syncInitialAttributes()
+          })
         }
         // initialize children
-        wrapper.slotChildren = Object.freeze(toVNodes(
-          wrapper.$createElement,
-          this.childNodes
-        ));
-        wrapper.$mount();
-        this.shadowRoot.appendChild(wrapper.$el);
+        wrapper.slotChildren = Object.freeze(
+          toVNodes(wrapper.$createElement, this.childNodes)
+        )
+        wrapper.$mount()
+        this.appendChild(wrapper.$el)
       } else {
-        callHooks(this.vueComponent, 'activated');
+        callHooks(this.vueComponent, 'activated')
       }
     }
 
-    disconnectedCallback () {
-      callHooks(this.vueComponent, 'deactivated');
+    disconnectedCallback() {
+      callHooks(this.vueComponent, 'deactivated')
     }
   }
 
   if (!isAsync) {
-    initialize(Component);
+    initialize(Component)
   }
 
   return CustomElement
 }
 
-export default wrap;
+export default wrap